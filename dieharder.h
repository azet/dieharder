/*
 *========================================================================
 * $Id$
 *
 * See copyright in copyright.h and the accompanying file COPYING
 *========================================================================
 */

#include "copyright.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <math.h>
#include <limits.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_sf.h>
#include <gsl/gsl_sort.h>
#include "tensor.h"

/*
 *========================================================================
 * Useful defines
 *========================================================================
 */

#define STDIN	stdin
#define STDOUT	stdout
#define STDERR	stderr
#define YES	1
#define NO	0
#define PI 3.141592653589793238462643

 typedef enum {
   D_QUIET,
   D_ALL,
   D_SEED,
   D_BITS,
   D_DIEHARD_RUNS,
   D_DIEHARD_BDAY,
   D_DIEHARD_2DSPHERE,
   D_DIEHARD_3DSPHERE,
   D_RGB_PERSIST,
   D_RGB_BITDIST,
   D_STS_MONOBIT,
   D_STS_RUNS,
   D_SAMPLE,
   D_KSTEST,
   D_BTEST,
   D_XTEST,
   N_DEBUG
 } Debug;

 typedef enum {
   QUIET,
   MEASURE,
   N_VERBOSE
 } Verbose;

 typedef enum {
   LIST_RNGS,
   LIST_RAND,
   BOGORATE,
   DIEHARD_RUNS,
   DIEHARD_BDAY,
   DIEHARD_2DSPHERE,
   DIEHARD_3DSPHERE,
   RGB_PERSIST,
   RGB_BITDIST,
   STS_MONOBIT,
   STS_RUNS,
   N_TEST
 } Tests;


 /*
  *========================================================================
  * Subroutine Prototypes
  *========================================================================
  */
 unsigned long int random_seed();
 void start_timing();
 void stop_timing();
 double delta_timing();
 void measure_rate();
 void Usage();
 double binomial(unsigned int n, unsigned int k, double p);
 double chisq_eval(double *x,double *y,double *sigma, unsigned int n);
 double chisq_poisson(uint *observed,double lambda,int kmax);
 double chisq_binomial(double *observed,double prob,uint kmax,uint nsamp);
 void dumpbits(unsigned int *data, unsigned int nbits);
 double sample(void *testfunc());
 double kstest(double *pvalue,int count);
 double kstest_kuiper(double *pvalue,int count);
 double q_ks(double x);
 double q_ks_kuiper(double x);
 /*
  * Tests.
  */
 double rgb_bitdist();
 void rgb_bitdist_test();
 double sts_monobit();
 void sts_monobit_test();
 double sts_runs();
 void sts_runs_test();


 /*
  *========================================================================
  *                           Global Variables
  *
  * The primary control variables:
  *
  *      psamples is the number of p-value samples to be taken and tested
  * with a KS test for any given test.
  *
  *      tsamples is the number of samples of any given quantity to be
  * accumulated for the test itself, e.g. the number of points generated
  * in 3dspheres or the number of bitstrings tested in rgb_bitdist.
  *
  *      size is the length of the rand_int vector that holds the random
  * (unsigned) integers generated by gsl_rng_get() for tests that require
  * a vector of random integers (such as bitstring tests).  Often, but
  * not always, size will equal tsamples.
  *
  *      bits is the length of the bitstring being tested for bit tests.
  * This defaults to rmax_int (the number of significant bits returned
  * by the rng which can be as low as 16).  bits is often directly related
  * to size -- for example if bits is 128 and rmax_int is 32, size is likely
  * to be 4 (the number of random integers required to produce a string of
  * 128 random bits).
  *
  *      ks_pvalue is the master list of p-values returned by tests. kspi
  * is the globel index/pointer into this list, so that all applications
  * that fill this list know where they are.  This is a bit ugly, but
  * alternative solutions are even uglier -- the number of pvalues returned
  * varies strongly per test from e.g. 1 for a single sample of monobit
  * to ntuple_max for bitdist tests.  For 100 samples, we therefore might
  * have (2^8 = 256)x100 ks_pvalues.  We dimension ks_pvalues according to
  * the input value of psamples as 256 x psamples.  This needs to be
  * increased if a test that generates more than 256 pvalues per test call
  * is added.
  *
  * Less important control variables:
  *
  *      iterations is the number of times the core loop is run (inserted 
  *        so one can minimize errors due to the gettimeofday call itself).
  *      verbose controls the output -- "normal" is verbose=1.
  *      reseed_flag controls whether or not to reseed for each independent
  *        sample.
  *      tv_start and tv_stop are used to record timings.
  *      dummy and idiot are there to fool the compiler into not optimizing
  *        empty loops out of existence so we can time one accurately.
  *      filename holds the name(s) of I/O file(s).
  *      fp is a file pointer for input or output purposes.
  *========================================================================
  */
 unsigned int psamples,tsamples,size,bits;
 /* dimensioned in startup */
#define KS_SAMPLES_PER_TEST_MAX 256
 double *ks_pvalue;
 unsigned int kspi;
 unsigned int quiet,verbose;
 unsigned int testnum,randnum,iterations,reseed_flag;
 struct timeval tv_start,tv_stop;
 int dummy,idiot;
 char filename[128];
 FILE *fp;

 /*
  * We need to set up a test specific control struct.  For example,
  * rgb_bitdist_test() can be run for all ntuples <= 8 until failure,
  * or it can be run for specific ntuples.  In order to be able to
  * use samples() to repeatedly run the tests, the tests cannot have
  * arguments (well, they can, but it is a PITA).  Hence the following
  * struct.  Note the very simple paradigm for adding control variables
  * as control.testname_variablename.
  */
 typedef struct {
   int rgb_bitdist_ntuple;   /* Negative means all tests */
 } Control;
 Control cntrl;

 /*
  * rng global vectors and variables for setup and tests.
  */
 const gsl_rng_type **types;    /* where all the rng types go */
 gsl_rng *rng;               /* global gsl random number generator */
 unsigned int *rand_int;        /* vector of "random" ints */
 unsigned int seed;             /* rng seed of run (?) */
 unsigned int random_max;       /* maximum rng returned by generator */
 unsigned int rmax;             /* scratch space for random_max manipulation */
 unsigned int rmax_bits;        /* Number of valid bits in rng */
 unsigned int rmax_mask;        /* Mask for valid section of uint */
 double *rand_uniform;          /* vector of "random" uniform deviates */
 int num_gsl_rngs,num_my_rngs,num_rngs;  /* number of rng's */


 /*
  * Looks like we'll need certain structs in order to be able to really
  * streamline and objectify the process of test->results->chisq->p-value
  * (and possibly even -> p-p-value, since p-values themselves should have
  * a distribution and we might do better running 30 samples of 1000 instead
  * of one sample of 30,000).
  */
 typedef struct {
   unsigned int npts;
   double p;
   double *x;
   double *y;
   double *sigma;
   double chisq;
   double pvalue;
   char testname[128];
   char rngname[128];
 } Ntest;

 typedef struct {
   unsigned int bins;
   double p;
   double *x;
   double *y;
   double *sigma;
   double chisq;
   double pvalue;
   char testname[128];
   char rngname[128];
 } Btest;

 typedef struct {
   unsigned int npts;
   double p;
   double x;
   double y;
   double sigma;
   double pvalue;
   char testname[128];
   char rngname[128];
 } Xtest;
 
