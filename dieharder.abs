<center><H1>DieHarder: A Random Number Test Suite</H1></center>

<center><H3>by Robert G. Brown (rgb)</H3></center>

<center><H2>Current: dieharder Version 0.5.9</H2></center>

<p>At the suggestion of Linas Vepstas on the Gnu Scientific Library
(GSL) list this GPL'd suite of random number tests will be named
"DieHarder".  Using a movie sequel pun for the name is a double tribute
to George Marsaglia, whose <a
href="http://stat.fsu.edu/~geo/diehard.html">"Diehard battery of
tests"</a> of random number generators has enjoyed years of enduring
usefulness as a test suite.</p>

<p>The DieHarder suite is more than just the diehard tests cleaned up
and given a pretty GPL source face in native C.  Tests from the <a
href="http://csrc.nist.gov/rng/">Statistical Test Suite (STS)</a>
developed by the National Institute for Standards and Technology (NIST)
are being incorporated, as are new tests developed by rgb.  Where
possible or appropriate, <i>all</i> tests that can be parameterized
("cranked up") to where failure, at least, is unambiguous are so
parameterized and controllable from the command line.</p>

<p>Note well that extensible DieHarder is intended to be the "Swiss Army
Knife of random number test suites", or if you prefer, "the last suite
you'll ever wear".  If that <i>last</i> pun isn't enough motivation for
any serious researcher that consumes lots of random numbers to give it a
try, then nothing is...</p>

<hr>

<center><h2><a href="./dieharder">DieHarder Download
Area</a></h2></center>

<p>The version numbers have the following meaning:

<ul> 

<li> First number (major).  Bumped only when major goals in the
design roadmap are reached (for example, finishing all the diehard
tests).

<li> Second number (first minor).  Bumped only when major design
features are added or altered.  For example, this new project page
accompanies the new 0.5.x release, where I completely rewrote the
command line options, global variable list, and the test structure so
that it was convenient and uniform for all tests that run so far.

<li> Third number (second minor).  The first digit is the combined
number of tests that are supported.  The second digit (if any) indicates
bug fixes or minor improvements.  When the number of tests reaches
double digits (shortly) the third digit will be the bugfix digit.

</ul>

<p> All dieharder source (.tgz and .src.rpm) files can be downloaded
from this directory.  In addition, i386 binary rpm's built on top of
Fedora Core 5 are present (that require that the GSL rpm's be
installed) as well.</p>

<p> This project is under very active development.  Some effort will be
expended from here on so that the suite will "run out of the box".  A
brief synopsis of command options to get you started as presented below.
In general, though, documentation (including this page and built in
documentation) may lag the bleeding edge snapshot by a few days or
more.</p>

<p>From Court Shrock:</p>
<pre>
I was reading about your work on dieharder.  First, some info
about getting dieharder working in Gentoo:

cd ~
emerge rpm gsl
wget
http://www.phy.duke.edu/~rgb/General/dieharder/dieharder-0.6.11-1.i386.rpm
rpm -i --nodeps dieharder-0.6.11-1.i386.rpm
</pre>

<p>Also, George Marsaglia retired from FSU in 1996, and diehard appears
to have finally disappeared from FSU webspace.  However, the diehard
CDROM is still mirrored <a
href="http://www.csis.hku.hk/~diehard/cdrom/">here</a> in what appears
to be an authorized copy.  The source code of diehard itself is of
course copyright George Marsaglia but Marsaglia did not incorporate an
explicit license into his code which muddles the issue.  Existing
diehard sources are not directly incorporated into dieharder in any way
in source form for that reason, to keep authorship and GPL licensing
issues clear.</p>

<hr>

<center><h2>About DieHarder</h2></center>

<p>The primary point of DieHarder (like Diehard before it) is to make it
easy to time and test (pseudo)random number generators, both software
and hardware for a variety of purposes in research and cryptography.
The tool is built entirely on top of the GSL's random number generator
interface and uses a variety of other GSL tools (e.g.  sort, erfc,
incomplete gamma, distribution generators) in its operation.  Three
examples are provided of wrapping a random number generator (including
the entropy-based /dev/random and /dev/urandom available on many linux
systems) and inserting it so that it is can be called via the GSL
interface, and it is strongly suggested that any random number generator
to be tested by provided with such an interface.</p>

<p>An file interface (still consistent with the GSL to the extent
possible) has been added that allows random numbers in either binary
unsigned integer or a variety of ascii encoded formats to be read in
from a file.  This permits dieharder to be used with "any" generator
(directly wrappable or not) that can generate a table of random numbers,
but this will place severe limits on some of the tests, which can
require very large numbers of random numbers.</p>  

<p>In this respect, DieHarder differs significantly from Diehard, which
used file based sources of random numbers exclusively and would "work"
with only a few million random numbers in such a file.  Modern random
number generators in a typical simulation application can easily need to
generate 10^18 or more random numbers, generated from hundreds,
thousands, millions of different seeds, over months to years of
accumlated run time and are therefore sensitive to weaknesses that might
not be revealed by such short sequences even with excellent and
sensitive tests.</p>

<p>This was, in part, the motivation for the development for the
Statistical Test Suite by NIST, which focusses more on cryptographical
strength (although the general testing methodology is much the
same).</p>

<p>The development of DieHarder was motivated by the following, in
rough order of importance:<p>

<ul>

<li> To provide a <b>readily available, rpm-installable toolset</b> so
that "consumers" of random numbers (who typically use <i>large</i>
numbers of random numbers in e.g. simulation or other research) can test
the generator(s) they are using to verify their quality.

<li> To provide a very <b>simple user interface</b> for that toolset for
random number consumers.  A GUI is on the list of things to do, although
it adds little to the practical utility of the tool.

<li> To provide lots of <b>lots of knobs and dials</b> and low level
control for statistical researchers that want to study particular
generators with particular tests in more detail.

<li> To have the entire test code and documentation be fully <b>Gnu
Public Licensed</b> and hence openly available for adaptation, testing,
comment, and modification so that the testing suite itself becomes
reliable and can be easily extended.

<li> To provide a fairly <b>simple API</b> for adding new tests with a
common set of low-level testing tools and a <b>common test structure</b>
that leads (one hopes) to an <i>unambiguous</i> decision to accept or
reject any given random number generator on the basis of any given test
for a suitable choice of controllable test parameters.

<li> To allow all researchers to be able to directly test, in
particular, the <b>random number generators interfaced with the GSL</b>.
This is a deliberate design decision justified by the extremely large
and growing number of random number generators prebuilt into the GSL and
the ease of adding new ones (either contributing them to the project or
for the sole purpose of local testing).

<li> To allow researchers that use e.g. <i>distributions</i> directly
generated by GSL random distribution generation routines (which can in
principle fail two ways, due to the failure of the underlying random
number generator or due to a failure of the generating algorithm) to be
able to directly validate their particular generator/distribution
combination, where possible.

</ul>

<p>Note well that the primary objections I have towards diehard and STS
are not that they are or are not adequate and complete; it is that the
code itself is not properly packaged for reuse, testing, and extension.
Diehard is remarkably poorly documented, as well, where STS is really
nothing <i>but</i> its description in documentation with no readily
available code for implementation.  DieHarder will hopefully rectify
both situations and be <i>both</i> well documented <i>and</i> available
in clearly publically licensed code to make it extremely easy for
anybody to test random numbers on any GSL-supported platform.</p>

<p>Although this tool is being developed on Linux/GCC-based platforms,
it should port with no particular difficulty to other Unices, especially
ones that support RPMs.  No particular effort is being expended at this
time to make it run on Windows based compute platforms (due to a lack of
availability of such platforms and compilers to rgb) but there is no
reason to think that such a port would be terribly difficult.</p>

<center><h2>Essential Usage Synopsis</h2></center>

<p>If you compile the test or install the provided binary rpm's and run
it as:</p>

<tt>dieharder -a</tt>

<p>it should run -a(ll) tests on the default GSL generator.</p>

<p>Choose alternative tests with -g number where</p>

<tt>dieharder -g -1</tt>
<p>will list all possible numbers known to the current snapshot of the
DieHarder (mostly from the GSL).</p>

<tt>dieharder -l</tt>

<p>should list all the tests implemented in the current snapshop of
DieHarder.  Finally, the venerable and time tested:</p>

<tt>dieharder -h</tt>

<p> provides a Usage synopsis (which can quite long) and</p>

<tt>man dieharder</tt>

<p>is the (installed) man page, which may or many not be completely up
to date as the suite is under active development.  For developers,
additional documentation is available in the toplevel directory or doc
subdirectory of the source tree.  Eventually, a complete DieHard manual
in printable PDF form will be available both on this website and in
/usr/share/doc/dieharder-*/.</p>

<center><h2>List of Random Number Generators and Tests
Available</h2></center>

<p>List of GSL and user-defined random number generators that can be
tested by DieHarder:</p>
<pre>
rgb@lilith|B:1344>dieharder
              Listing available built-in gsl-linked generators:           |
 Id Test Name           | Id Test Name           | Id Test Name           |
==========================================================================|
  0 borosh13            |  1 cmrg                |  2 coveyou             |
  3 fishman18           |  4 fishman20           |  5 fishman2x           |
  6 gfsr4               |  7 knuthran            |  8 knuthran2           |
  9 lecuyer21           | 10 minstd              | 11 mrg                 |
 12 mt19937             | 13 mt19937_1999        | 14 mt19937_1998        |
 15 r250                | 16 ran0                | 17 ran1                |
 18 ran2                | 19 ran3                | 20 rand                |
 21 rand48              | 22 random128-bsd       | 23 random128-glibc2    |
 24 random128-libc5     | 25 random256-bsd       | 26 random256-glibc2    |
 27 random256-libc5     | 28 random32-bsd        | 29 random32-glibc2     |
 30 random32-libc5      | 31 random64-bsd        | 32 random64-glibc2     |
 33 random64-libc5      | 34 random8-bsd         | 35 random8-glibc2      |
 36 random8-libc5       | 37 random-bsd          | 38 random-glibc2       |
 39 random-libc5        | 40 randu               | 41 ranf                |
 42 ranlux              | 43 ranlux389           | 44 ranlxd1             |
 45 ranlxd2             | 46 ranlxs0             | 47 ranlxs1             |
 48 ranlxs2             | 49 ranmar              | 50 slatec              |
 51 taus                | 52 taus2               | 53 taus113             |
 54 transputer          | 55 tt800               | 56 uni                 |
 57 uni32               | 58 vax                 | 59 waterman14          |
 60 zuf                 |
                   Listing available non-gsl generators:                  |
 Id Test Name           | Id Test Name           | Id Test Name           |
==========================================================================|
 61 /dev/random         | 62 /dev/urandom        | 63 empty               |
 64 file_input          | 65 file_input_raw      |
</pre>

<p>Note that the last five tests are examples of random number
generators that have been wrapped up in GSL compatible clothes and
linked to the GSL so that the standard GSL interface works for them.
<i>Any</i> random number generator that one wishes to test can thus
easily be added for testing using these as prototypes, and can likely be
submitted to the GSL for inclusion if they pass the tests as well or
better than the tests that are already there.  That makes this a <i>very
convenient tool</i> for testing new RNGs.</p>

<p>Note also that the last two non-gsl generators are "universal"
generators in the sense that they permit you to input your OWN random
number stream from a file (but NOT from /dev/random or /dev/urandom, be
warned).  The file_input generator requires a file of "cooked" (ascii
readable) random numbers, one per line, with a header that describes the
format to dieharder.  This interface is still somewhat experimental --
not all ascii formats have been tested.  However, it has been tested and
should work for 32 bit unsigned integers represented directly in ascii
or as 32 bits of binary.  An example of the required header for these
formats is given here:</p>
<pre>
#==================================================================
# generator mt19937_1999  seed = 1274511046
#==================================================================
type: u
count: 100000
numbit: 32
3129711816
  85411969
2545911541
 903839182
2564046000
1157728411
 202655667
 969286899
1519043834
... (for 100,000 rands total).
</pre>
<pre>
#==================================================================
# handmade.  Comments are ignored, obviously.
#==================================================================
type: b
count: 10
numbit: 32
00000000000000000000000000000001
00000000000000000000000000000010
00000000000000000000000000000011
00000000000000000000000000000100
00000000000000000000000000000101
00000000000000000000000000000110
00000000000000000000000000000111
00000000000000000000000000001000
11111111111111111111111111111111
11111111111111110000000000000000
</pre>
<p>(where the latter is clearly not very random).</p>

<p>The last type, file_input_raw, accepts a file of raw bits as input,
such as might be generated by
<pre>
 dd if=/dev/urandom of=testrands.raw bs=4 count=1000000
</pre>
(to generate 1,000,000 four-byte ints directly from the
software-augmented kernel entropy generator).  That is, running the
tests from such a file should be <i>approximately</i> the same as
testing /dev/urandom directly.</p>

<p>The main (important!) difference is that some of the test require a
<i>lot</i> of random numbers -- far more than were needed by diehard.
Indeed, dieharder runs many of the diehard tests 100 <i>independent</i>
times, generating a p-value for each, and plots a histogram of the
p-values and generates a p-value for the (presumed uniform) distribution
of p-values!  This approach mimics the histogram presented in the STS
suite but augments it with a hard number.</p>  

<p>It protects one from the "p happens" problem -- every now and then
you <i>will</i> have a run with a very low or high p from a <i>good</i>
generator, but a good generator will generate a uniform distribution of
p-values.  Dieharder lets you visually decide if the distribution is or
isn't credibly uniform, while giving you an index that in most cases is
a fairly clear "good" or "bad" indicator for a given random sequence or
generator.</p>

<p>File input rands are delivered to the tests on demand, but if the
test needs more than are available it simply rewinds the file and cycles
through it again, and again, and again as needed.  Obviously this
signifnicantly reduces the sample space and can lead to completely
incorrect results for the p-value histograms unless there are enough
rands to run EACH test without repetition (it is harmless to reuse the
sequence for different tests).  Let the user beware!</p>

<p>List of the CURRENT fully implemented tests (as of the 07/07/06
snapshot):</p>
<pre>
rgb@lilith|B:1346>dieharder -l

                     DieHarder Test Suite
========================================================================
The following tests are available and will be run when diehard -a is
invoked.  Special options or suggested parameters are indicated if
they are needed to get a satisfactory result (such as completion in a
reasonable amount of time).

            Diehard Tests
   -d 1 Diehard Runs test
   -d 2 Diehard Birthdays test (-t 100, or less than 200) 
   -d 3 Diehard Minimum Distance (2D Spheres) test
   -d 4 Diehard 3D Spheres (minimum distance) test
   -d 5 Diehard 32x32 Binary Rank test
   -d 6 Diehard 6x8 Binary Rank test
   -d 7 Diehard Parking Lot test
   -d 8 Diehard Craps test
   -d 9 Diehard Squeeze test
   -d 10 Diehard Bitstream test
   -d 11 Diehard OPSO test
   -d 12 Diehard OQSO test
   -d 13 Diehard DNA test

             RGB Tests
   -r 1 Bit Persist test
   -r 2 Bit Ntuple Distribution test suite (-n ntuple for 1-8)
   -r 3 Timing test (times rng)

      Statistical Test Suite (STS)
   -s 1 STS Monobit test
   -s 2 STS Runs test

            User Tests
No user-developed test are installed at this time.
</pre>

<p>Note that the design goal of completely encapsulating diehard is
nearing completion with 8 tests supported and (apparently)
functional as of 7/7/06.</p>

<p>Full descriptions of the tests are available (as you can see) from
within the tool and source documentation.  All tests are completely and
independently rewritten from their description alone, and may be
functionally modified or extended relative to the original source code
published in the originating suite.  The author (rgb) bears complete
responsibility for these changes, subject to the standard GPL code
disclaimer (in essence, yes it's my fault if they don't work but using
the tool is at your own risk).</p>

<center><h2>Development Notes</h2></center>

<p>All tests are currently using the x.6.x test encapsulation and
underlying KS and chisq tests.  I'm in the process of adding the rest of
Diehard as fast as I can rewrite them in the standard test encapsulation
while adding new generators (e.g. file input) and debugging as needed.
Some of the tests will likely require extension of the underlying tools,
e.g.  covariance matrix to p-value, that I'm hoping is facilitated by
the GSL.  I also have my eye on the as-yet unimplemented tests from
Knuth's <i>The Art of Programming</i> and lagged correlation.</p>

<center><h2>Thoughts for the Future/Wish List/To Do</h2></center>

<ul>

<li> Tests of GSL distribution generators. 

<li> Anderson-Darling KS test.

<li> Covariance matrix to p-value (required by various Diehard tests).

<li> STS binning of final p-value sampling to determine uniformity
(alternative to KS test).

<li> New tests, compressions of existing ones that are "different" but
really the same.  Hyperplane tests.  Spectral tests.

<li> Collaborators.  Co-developers welcome, as are contributions from
users.

</ul>

<center><h2>Screen Shots (sort of)</h2></center>

<p>An example: The result of running the Diehard runs test on a
generator that clearly passes (mt19937) and one that clearly fails
(randu):</p>

<pre>
rgb@lilith|B:1350>dieharder -d 1 -g 12

#==================================================================
#                Diehard "runs" test (modified).
# This tests the distribution of increasing and decreasing runs
# of integers.  If called with reasonable parameters e.g. -s 100
# or greater and -n 100000 or greater, it will compute a vector
# of p-values for up and down and verify that the proportion
# of these values less than 0.01 is consistent with a uniform
# distribution.
#==================================================================
# Random number generator tested: mt19937
# size of vector tested = 10000 (100000 or more suggested)
# p = 0.102725 for diehard_runs test from Kuiper Kolmogorov-Smirnov
#     test on 200 pvalues (up runs + down runs).

rgb@lilith|B:1352>dieharder -d 1 -g 40

#==================================================================
#                Diehard "runs" test (modified).
# This tests the distribution of increasing and decreasing runs
# of integers.  If called with reasonable parameters e.g. -s 100
# or greater and -n 100000 or greater, it will compute a vector
# of p-values for up and down and verify that the proportion
# of these values less than 0.01 is consistent with a uniform
# distribution.
#==================================================================
# Random number generator tested: randu
# size of vector tested = 10000 (100000 or more suggested)
# p = 0.006163 for diehard_runs test from Kuiper Kolmogorov-Smirnov
#     test on 200 pvalues (up runs + down runs).
</pre>

<p>In the latter case, the value of p indicates that there is only a
0.6% chance that a perfect random number generator could have produced
the observed distribution of p-values from 100 independent runs of 10000
samples each.  It is thus unlikely (in a manner of speaking) that randu
is a good random number generator, but it is still possible -- even a
perfect generator <i>could</i> have produced the observed result, it
just isn't likely.  One advantage of dieharder is that one can easily
crank up the number of samples per test (-t) to make failure
certain:</p> 
<pre> 
rgb@lilith|B:1355>dieharder -d 1 -g 40 -t 1000000

#==================================================================
#                Diehard "runs" test (modified).
# This tests the distribution of increasing and decreasing runs
# of integers.  If called with reasonable parameters e.g. -s 100
# or greater and -n 100000 or greater, it will compute a vector
# of p-values for up and down and verify that the proportion
# of these values less than 0.01 is consistent with a uniform
# distribution.
#==================================================================
# Random number generator tested: randu
# size of vector tested = 1000000 (100000 or more suggested)
# p = 0.000000 for diehard_runs test from Kuiper Kolmogorov-Smirnov
#     test on 200 pvalues (up runs + down runs).
# Generator randu FAILS at 0.01% for diehard_runs.
</pre>

<p>randu <i>fails</i> this test.  To be more precise, the probability
that randu is a "good" generator but produced the observed distribution
is less than 0.000001, according to this test.  mt19937, on the other
hand, still returns perfectly reasonable values of p from the final KS
test, even when run repeatedly with still larger -t.</p>

<p>All the tests have a similar call format, and share control
parameters to the extent possible.  At this point I expect to live with
the overall structure and encapsulation of the tests for a while (after
completing a fairly major overhaul) and will spend time in the near term
just adding tests.</p>

<center><h2>Conclusions</h2></center>

<p>I hope that even during development, you find dieharder useful.  If
you have any interest in participating in its development, be sure to
let me know, especially if you have decent coding skills and a basic
knowledge of statistics.  I have documents to help with the latter, if
you have the programming skills and want to LEARN statistics.</p>

<p>Submit bug reports, etc. to</p>
<address>
  <a href="mailto:rgb@phy.duke.edu">rgb@phy.duke.edu</a> 
</address>
