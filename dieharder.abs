<H2>rand_rate Version 0.4.42</H2>

<p>Click <a href="./rand_rate">here</a> to see a list of all rand_rate
files on this repository.</p>

<p> This is the current snapshot of the <b>rand_rate</b> random number
tester.  It encapsulates all of the Gnu Scientific Library random number
generators as well as /dev/random and /dev/urandom in a single harness
that can time them and subject them to various tests for randomness.
These tests are variously drawn from Marsaglia's "Diehard" battery of
random number tests, the NIST STS tests, useful e.g. binning or spectral
tests that I've found doing research into random number tests or tests
that I myself have made up or that are improvements on tests from other
sources.</p>

<p> The primary point of this tester is to make it easy to time and test
(pseudo)random number generators OR hardware or other generators.  Three
examples are provided of wrapping a random number generator and
inserting it so that it is can be called via the GSL interface.  An
interface is planned that would allow random numbers to be read in from
a file, allowing the tool to be used with any generator (wrappable or
not) that can generate a table of random numbers.</p>

<p>Another important motivation for writing rand_rate is to have the
entire test code and documentation be fully Gnu Public Licensed and
hence openly available for adaptation, testing, modification, including
the addition of new tests.  The primary objections I have towards
diehard and sts are not that they are or are not adequate and complete;
it is that the code is obscure and not explicitly published for reuse.
It is my hope that by providing this tool in autodocumenting source, it
makes it easy to add new tests, critique older tests, and improve the
suite in general.
</p>

<p>The following are the tests so far implemented and (possibly)
functional:</p>

<h2>List of Tests/Comments</h2>

<ul>

<li> Diehard: Knuth "runs" test.

<p>Works OK. Pretty much the way it is described in the original
documentation, but very definitely new/clean original C code.</p>

<li> Diehard: Poissonian "Birthdays" test.

<p>Works well with KS test, need to choose -s 500.  I fancied it up a bit
-- use GSL's rmax_bits correctly, use a cyclic permutation under a 24
bit mask to do all 32 cyclic permutations of bit position, not just 9 a
la Marsaglia, use Pearson's chisq directly computed from
gsl_ran_poisson_pdf() and the observations per cycle.  Good at solidly
rejecting bad generators (try -r 40, randu, as the universal "bad
generator":-).</p>

<li> Diehard: (2d) Minimum Distance test.

<p>This works well, uses KS test on lots of samples.  It's relatively
slow as it has to test a lot of pairs of points to float out the minimum
distance, and I haven't written this optimally (yet) out of sheer
laziness.  It requires e.g. an index sort and while doing primary
development a prefer brute force.</p>

<li> Diehard: (3d) Minimum Distance test. 

<p>This works well also and is in fact the same test as the 2d test
above but yields a different target distribution.  Again, I'm not
sorting to find the minimum (yet) and checking all the pairs of points
is relatively slow, if sure.</p>

<li> rgb: Bitmask test.

  <p>This is one of my own clever ideas.  Some rng's, for some seeds,
have bits that don't change. Obviously that makes the rng's bad, but bad
in a somewhat different way than "just" non-randomness of some more
occult order.  This is a very fast test that can iterate samples over
seeds and extract a collective mask of all the bits that didn't change
for an entire sequence of rands for at least one seed in the test.  Very
efficiently rejects e.g. randu (GSL 40).</p>

<li> rgb: Single bit binomial distribution test.

 <p>This is a nice test that is similar (possibly identical, I haven't
decided) to some sts tests that look at bit distributions.  If you look
at random e.g. 128 bit words, you expect to see a binomial distribution
of the total 1 bit count per word centered on 64.  This test is now
fixed and appears to work quite well.</p>

<li> rgb: Pairwise bit binomial distribution test.

 <p>Broken, but now that I have the single bit test running well I
can rewrite this one as it is identical except that it checks
bit pairs instead of single bits.  To write it efficiently (and in fact
to generalize the binomial cod above) I need to combine cycle with
get_bit to create a cyclic "window" retrieval function that returns the
integer value of an index-specified bit window on the integer, with
periodic wraparound.</p>

<p>Then it should be easy to completely automate this so that one can
test arbitrary n-tuples of bits for the right frequency distribution,
across all cyclic permutations of the source words.  I think that this
would eat/replace several of the Diehard tests and a few of the STS
tests which all seem to do this same thing, but not as plainly and maybe
not as well.  Note that doing a series of these tests is like testing
moments -- if single bits are correctly distributed (50/50 binomial) and
bitpairs are correctly distributed (25/75 binomial for all pairs) and
bit triplets are correctly distributed and bit octets are correctly
distributed (etc) it is hard to see how the rands themselves won't be
correctly (randomly) distributed.</p>

<li> STS: monobit test.

 <p>This is a weak (but still useful) version of the counting of 1's in
a word of N bits that examines the number of 1's in a very long list of
bits and compares it to N/2.  Here one can be very sure chisq and p are
correctly computed per trial in the STS prescription, but the test now
collects a vector of p's and applies a KS test rather than forcing you
to run it lots of times by hand and visually assess the p distribution
as "uniform" (or using the other methods described in the STS
documentation).  Weak or not, monobit can definitely find truly weak
rng's.  Not so good in general, as it is quite possible for an rng to
yield the right fraction of 1's and 0's but still be very nonrandom.</p>

<li> STS: runs test (counts runs of 0's and 1's).

 <p>This is distinct from Diehard's runs.  In fact, this test is TRYING
to compute what I will eventually compute far more directly in the
pairwise bit distribution, since runs of 0's or 1's always end on a 01
or 10 pair, right?  1/4 of all pairs should be 01, 1/4 should be 10, 1/4
should be 11, 1/4 should be 00.  Why bother calling it "runs" (or
counting the intervening bits)?  Just count the damn pairs!</p>

</ul>

<p>Notes on current activity:  I added a KS test to analyze a vector of
p-values to ensure that they are uniform on 0,1 over many independent
sampling runs PER test, so that a test can yield a single statistic that
is absolutely consistent across all tests.  Printing the KS data out as
it is computed from a sorted list of p-values is also very useful in
trying to determine whether or not it appears uniform to the eye.</p>

<p>As I finish improved Pearson chisq estimators and the KStest, I
expect to fly through some of the still-missing Diehard tests and dig
into the sts tests.  I also think that it would be "interesting" to
apply this exact framework to the GSL distribution generators as a test
of random numbers TOTALLY within the GSL -- if one simply (e.g.) samples
a poissonian using randu as your rng and compare the result to the
poissonian probability density function to compute Pearson's chisq and a
p-value (vector) and eventually a KS p-value, does that prove to be as
sensitive a test as the various (far more complex) STS and Diehard
tests.  For example, the birthday test seems like a difficult way to
generate a Poissonian compared to just "doing it" from an rng.  Is there
any evidence that it has greater sensitivity to various failures of the rng
than a test that didn't have to achieve an asymtotic limit (large bit
windows, many birthdays, many samples) in order to become Poissonian in
the first place?</p>

<p>Anyway, I hope that you find rand_rate useful.  If you have any
interest in participating in its development, be sure to let me know,
especially if you have decent coding skills and a basic knowledge of
statistics.  I have documents to help with the latter, if you have the
programming skills and want to LEARN statistics.</p>
